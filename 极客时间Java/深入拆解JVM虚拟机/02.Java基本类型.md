Java 中有八种基本类型,用于支持数值计算,这么做主要是基于工程考虑,引入这些基本类型可以提高程序执行效率以及内存使用情况.

## JVM 的 boolean 类型

JVM 虚拟机中, boolean 类型被映射为 int 类型, "true" 被映射为 1, "false" 被映射为整数0.

对 JVM 虚拟机来说,它看到的 boolean 类型已经被映射为整数类型,因此,原本声明为 boolean 类型的局部变量,赋值为除了0,1之外的整数值,在 Java 虚拟机看来是合法的.

## Java 基本类型

| 类型 | 值域 | 默认值 | 虚拟机内部符号 |
|:----:|:---:|:------:|:-------------:|
| boolean | {false, true} | false | Z |
| byte | [-128, 127] | 0 | B |
| short | [-32768, 32767] | 0 | S |
| char | [0, 65535] | '\u0000' | C |
| int | [-2^32, 2^31-1] | 0 | I |
| long | [-2^63, 2^63-1] | 0L | J |
| float | ~[3.4E38, 3.4E38] | +0.0F | F |
| double | ~[-1.8E308, 1.8E308] | +0.0D | D |

从上到下类型可以直接转换,无需强制转换. 尽管他们默认值看起来不同,但在内存中都是0.

只有 boolean 和 char 这两种类型是无符号的,通常可以认为 char 类型是非负数.

可以将 2 存储到 boolean 类型中,另外 byte/char/short 类型也可以存储超过他们取值范围的数值,但是会带来一些麻烦.

Java 的浮点类型以 float 为例通常有两个0, +0.0F 和 -0.0F, java 中 `+0.0F == -0.0F` 返回 true.

Java 中正无穷和负无穷使用十六进制可以分别表示为 `0x7F800000` 和 `0XFF800000`. `0x7F800001` 表示的浮点数是 `NaN(Not a Number)`.不仅如此，[0x7F800001, 0x7FFFFFFF]和 [0xFF800001, 0xFFFFFFFF] 对应的都是 NaN。

NaN 有一个有趣的特性：除了“!=”始终返回 true 之外，所有其他比较结果都会返回 false。

## Java类型的大小

boolean 类型在 Java 虚拟机中被映射为整数类型：“true”被映射为 1，而“false”被映射为 0。

除 boolean 类型之外，Java 还有另外 7 个基本类型。它们拥有不同的值域，但默认值在内存中均为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑 +0.0F、-0.0F 以及 NaN 的情况。

除 long 和 double 外，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的，但它们在堆中占用的大小确不同。在将 boolean、byte、char 以及 short 的值存入字段或者数组单元时，Java 虚拟机会进行掩码操作。在读取时，Java 虚拟机则会将其扩展为 int 类型。