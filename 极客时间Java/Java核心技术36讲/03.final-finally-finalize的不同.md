这是 Java 语言中常用的关键字和方法，其实没什么关系。

## final, finally, finalize

final 是用来修饰类、方法、变量的，修饰 class 类时表示该类不可继承扩展，修饰变量时表示该变量不可修改，修饰方法时表示该方法不可继承。

finally 是 Java 保证重点代码一定要执行的一种机制，可以使用 tyr-catch-finally 或 try-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。

finalize 是基础类 java.lang.Object 的一个方法，它设计的目的是保证对象在被垃圾回收前完成特定的资源回收，已经不推荐使用，在 JDK9 中标记为过时的。这是因为：

1. 不能保证被执行

    程序被强制终结，不会调用finalize方法 
    
    finalize方法执行时抛出异常，不会继续执行

2. 不能保证及时被执行

    对时间敏感的任务不能在finalize中执行，譬如文件资源回收

3. 性能损失

4. 移植性差 

    不同JVM实现的GC不同，导致finalize在不同平台不一定都能运行

## 考点
1. final

    推荐使用final 关键字来表示我们代码的语义、逻辑意图。

    比如一些基础库中的类中很多方法都使用了 final 修饰，这样可以避免 API 使用者更改基础功能，保证平台安全。

    - 使用 final 修饰参数或者变量可以避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明为 final

    - final 变量产生了某种程度的不可变的效果，可用于数据保护，尤其是并发编程中，可以减少额外的同步开销，节省一些防御性拷贝的必要。

    final 对性能的影响几乎可以不用考虑。

2. finally

    对于需要关闭连接的资源的情况其实更推荐的做法是使用 try-with-resources 语句，因为通常 Java 平台能够更好地处理异常情况，编码量也少很多。

    ```java
    try {
        // do something
        System.exit(1);
    } finally{
        System.out.println(“Print from finally”);
    }
    ```

    这段代码的打印语句是不会被执行的。


3. finalize

    业界都不推荐使用 finalize ，因为无法保证 finalize 什么时候执行，使用不当会影响戏能，导致死锁，挂起等。

## 扩展

1. final 不等同于 immutable ，比如：

    ```java
    final List<String> strList = new ArrayList<>();
    strList.add("Hello");
    strList.add("world");  
    List<String> unmodifiableStrList = List.of("hello", "world");
    unmodifiableStrList.add("again");
    ```

    final 只能约束 strList 这个引用不可以被赋值，但是 strList 对象的行为不受约束，添加元素等操作都是可以的。但是使用 List.of 创建的对象是不可变的，所有最后的 add 语句会抛异常。

    immutable 在很多场景下都是很好的选择，java 语言没有原生支持不可变，要实现 immutable 的类，需要做到：

    1. 将 class 声明为 final，这样别人就不能通过扩展来绕过限制了。

    2. 将所有成员变量定义为 private 和 final，并且不实现 setter 方法。

    3. 构造对象时，使用深拷贝来初始化，不直接赋值，这是一种防御措施，因为无法确定输入对象不被其他人修改。

    4. 如果确实要实现 getter 方法，或者其他返回内部状态的方法，使用 copy-on-write 原则，创建私有 copy

