> Java 中，除了原始数据类型的变量，其他所有都是引用类型，指向各种不同的对象，理解引用对于掌握 Java 对象声明周期和 JVM 内部关键机制非常有帮助。

## 强引用、软引用、弱引用、幻象引用有什么区别，具体使用场景是什么

> 不同的引用类型，主要体现的是对象不同的可达性(reachable)状态和对垃圾回收的影响。

强引用(strong reference)，就是常见的普通对象引用，只要强引用指向一个对象，就表明这个对象还“活着”，垃圾收集器就不会回收这个对象。一个普通对象如果没有其他的引用关系，只要超过引用的作用域或显式将强引用赋值为 null ，就可以被垃圾收集器回收，具体也要看垃圾收集策略。

软引用(softreference)，是一种相对强化引用弱一点，只有在 JVM 认为内存不足时才会回收软引用的对象，JVM 会确保抛出 `OutOfMemoryError` 之前清理所有软引用。软引用通常用于实现内存敏感的缓存，可以保证缓存的使用同时不会耗尽内存。

弱引用(WeakReference) 并不能式对象豁免垃圾收集，仅是提供一种访问弱引用状态下的途径，比如维护一种非强制的映射关系，如果试图获取的对象还在，就使用它，否则重新实例化，弱引用同样是很多缓存实现的选择。

幻象引用有时候也叫虚引用，不能通过它访问对象，仅提供一种确保对象被 finalize 后做某些事情，如通常用来做 Post-Morterm 清理机制、Java平台自身 Cleaner 机制等，也可以监控对象的创建和销毁。

## 扩展

1. 对象可达性状态流分析
 
![1](https://static001.geekbang.org/resource/image/36/b0/36d3c7b158eda9421ef32463cb4d4fb0.png)

    强可达：不通过各种引用就可以访问到的对象，如新建一个对象，创建它的线程对他就是强可见。

    软可达：必须托诺更说软引用才能访问到。

    弱可达：只能通过弱引用访问，十分临近 finalize 状态，弱引用被清除的时候就符合 finalize 的条件了。

    幻象可达：没有强、软、弱引用关联，并且 finalize 过了，只有幻想引用指向这个对象的时候。

    不可达：意味着这个对象已经被清除。

    利用软引用和弱引用的 `get` 方法可以重新指向强引用，也就是可以认为改变对象的可达状态！

    垃圾回收机制会二次确认软引用和弱引用的对象，确保对象状态没有被改为强引用。

    但是这有个问题，如果我们错误地保持了强引用（比如赋值给 static 变量），对象就不会被回收，造成内存泄露。

2. 引用队列(ReferenceQueue)使用

    利用引用队列可以再对象处于相应状态时执行后期处理逻辑。

    不理解

3. 显示影响软引用垃圾手机

    从 Java1.3.1 开始，可以使用 `-XX:SoftRefLRUPolicyMSPerMB` 来指定多长时间后可以进行软引用的垃圾回收。

4. 诊断 JVM 引用情况

    JDK8 中可以使用 `-XX:+PrintReferenceGC` 可以获取 JVM 的相关信息：

    ```
    -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintReferenceGC
    ```

    ```
    0.403: [GC (Allocation Failure) 0.871: [SoftReference, 0 refs, 0.0000393 secs]0.871: [WeakReference, 8 refs, 0.0000138 secs]0.871: [FinalReference, 4 refs, 0.0000094 secs]0.871: [PhantomReference, 0 refs, 0 refs, 0.0000085 secs]0.871: [JNI Weak Reference, 0.0000071 secs][PSYoungGen: 76272K->10720K(141824K)] 128286K->128422K(316928K), 0.4683919 secs] [Times: user=1.17 sys=0.03, real=0.47 secs] 
    ```
